#include <msp430g2553.h>
#include <string.h>

/**
 * main.c
 */

void flash_spi_detected(void) {
    int i=0;
    P1OUT = 0;
    for (i=0; i < 6; ++i) {
        P1OUT = ~P1OUT;
        __delay_cycles(0x4fff);
        __delay_cycles(0x4fff);
    }
}

unsigned int delay_a = 1000000000;
unsigned int delay_b = 1000000000;

void main(void)
{
	WDTCTL = WDTPW | WDTHOLD;	// stop watchdog timer
	
	/* led */
	  //P1DIR |= BIT0 + BIT5;
	  P1DIR |= BIT0;
	  __delay_cycles(1000000); //delay to ensure slave is ready to accept from master
	  while (P1IN & BIT5);                   // If clock sig from mstr stays low,
	  __delay_cycles(1000000);
	                                            // it is not yet in SPI mode

	  flash_spi_detected();                 // Blink 3 times

	  P1SEL = BIT4 + BIT5 + BIT6 + BIT7;
	  P1SEL2 = BIT4 + BIT5 + BIT6 + BIT7;
	  UCB0CTL1 = UCSWRST;                       // **Put state machine in reset**
	  UCB0CTL0 |= UCMSB + UCSYNC + UCCKPH + UCMODE_2;               // 4-pin, 8-bit SPI master
	  UCB0CTL1 &= ~UCSWRST;                     // **Initialize USCI state machine**
	  IE2 |= UCB0RXIE + UCB0TXIE;               // Enable USCI0 RX interrupt

	  __bis_SR_register(LPM4_bits + GIE);       // Enter LPM4, enable interrupts

	  P2DIR |= BIT0 + BIT1;
	  P2OUT &= ~BIT0 + BIT1;

	  unsigned int counter_a = 0;
	  unsigned int counter_n = 0;
////////////////////LED1 Delay////////////////////////
	if(counter_a == delay_a){
	    counter_a = 0;
	    P2OUT ^ BIT0;                           //toggle LED
	}
	else{
	    counter_a = counter_a + 1;
	}
////////////////////LED2 Delay//////////////////////
	if(counter_b == delay_b){
	    counter_b = 0;
	    P2OUT ^ BIT1;                           //toggle LED
	}
	else{
	    counter_b = counter_b + 1;
	}
}

#pragma vector=USCIAB0RX_VECTOR
__interrupt void USCI0RX_ISR(void)
{
    /*
    if (UCB0STAT & UCOE) {
    P1OUT |= BIT0;
  }
  */
    char value = UCB0RXBUF;
    if(value = 'c'){
        delay_a = delay_a / 2;
    }
    else if(value = 'd'){
        delay_a = delay_a * 2;
    }
    else if(value = 'e'){
        delay_b = delay_b / 2;
    }
    else if(value = 'f'){
        delay_b = delay_b * 2;
    }

}

#include <msp430g2553.h>
#include <string.h>

/**
 * main.c
 */

void flash_spi_detected(void) {
    int i=0;
    P1OUT = 0;
    for (i=0; i < 6; ++i) {
        P1OUT = ~P1OUT;
        __delay_cycles(0x4fff);
        __delay_cycles(0x4fff);
    }
}

unsigned int delay_a = 1000000000;
unsigned int delay_b = 1000000000;

void main(void)
{
	WDTCTL = WDTPW | WDTHOLD;	// stop watchdog timer
	
	/* led */
	  //P1DIR |= BIT0 + BIT5;
	  P1DIR |= BIT0;
	  __delay_cycles(1000000); //delay to ensure slave is ready to accept from master
	  while (P1IN & BIT5);                   // If clock sig from mstr stays low,
	  __delay_cycles(1000000);
	                                            // it is not yet in SPI mode

	  flash_spi_detected();                 // Blink 3 times

	  P1SEL = BIT4 + BIT5 + BIT6 + BIT7;
	  P1SEL2 = BIT4 + BIT5 + BIT6 + BIT7;
	  UCB0CTL1 = UCSWRST;                       // **Put state machine in reset**
	  UCB0CTL0 |= UCMSB + UCSYNC + UCCKPH + UCMODE_2;               // 4-pin, 8-bit SPI master
	  UCB0CTL1 &= ~UCSWRST;                     // **Initialize USCI state machine**
	  IE2 |= UCB0RXIE + UCB0TXIE;               // Enable USCI0 RX interrupt

	  __bis_SR_register(LPM4_bits + GIE);       // Enter LPM4, enable interrupts

	  P2DIR |= BIT0 + BIT1;
	  P2OUT &= ~BIT0 + BIT1;

	  unsigned int counter_a = 0;
	  unsigned int counter_n = 0;
////////////////////LED1 Delay////////////////////////
	if(counter_a == delay_a){
	    counter_a = 0;
	    P2OUT ^ BIT0;                           //toggle LED
	}
	else{
	    counter_a = counter_a + 1;
	}
////////////////////LED2 Delay//////////////////////
	if(counter_b == delay_b){
	    counter_b = 0;
	    P2OUT ^ BIT1;                           //toggle LED
	}
	else{
	    counter_b = counter_b + 1;
	}
}

#pragma vector=USCIAB0RX_VECTOR
__interrupt void USCI0RX_ISR(void)
{
    /*
    if (UCB0STAT & UCOE) {
    P1OUT |= BIT0;
  }
  */
    char value = UCB0RXBUF;
    if(value = 'c'){
        delay_a = delay_a / 2;
    }
    else if(value = 'd'){
        delay_a = delay_a * 2;
    }
    else if(value = 'e'){
        delay_b = delay_b / 2;
    }
    else if(value = 'f'){
        delay_b = delay_b * 2;
    }

}
